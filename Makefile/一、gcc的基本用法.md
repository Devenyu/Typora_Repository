# 一、gcc的基本用法

使用gcc 编译器时，必须给出一系列必要的调用参数和文件名称。不同参数的先后顺序对执行结果没有影响，只有在使用同类参数时的先后顺序才需要考虑。如果使用了多个 -L 的参数来定义库，gcc 会根据多个 -L 参数的先后顺序来执行相应的库目录。

gcc编译器的调用参数大约有100多个，其中多数参数我们可能根本就用不到，这里只介绍其中最基本、最常用的参数。

gcc最基本的用法是：`gcc [options] [filenames]`

其中，options就是编译器所需要的参数，filenames给出相关的文件名称，最常用的有以下参数：

```makefile
-c ：只编译，不链接成为可执行文件。编译器只是由输入的 .c 等源代码文件生成 .o 为后缀的目标文件，通常用于编译不包含主程序的子程序文件。

-o output_filename ：确定输出文件的名称为output_filename。同时这个名称不能和源文件同名。如果不给出这个选项，gcc就给出默认的可执行文件 a.out 。

-g：产生符号调试工具（GNU的 gdb）所必要的符号信息。想要对源代码进行调试，就必须加入这个选项。

-O：对程序进行优化编译、链接。采用这个选项，整个源代码会在编译、链接过程中进行优化处理，这样产生的可执行文件的执行效率可以提高，但是编译、链接的速度就相应地要慢一些，而且对执行文件的调试会产生一定的影响，造成一些执行效果与对应源文件代码不一致等一些令人“困惑”的情况。因此，一般在编译输出软件发行版时使用此选项。

-O2：比 -O 更好的优化编译、链接。当然整个编译链接过程会更慢。

-Idirname：将 dirname 所指出的目录加入到程序头文件目录列表中，是在预编译过程中使用的参数。
```

>注：
>
>C程序中的头文件包含两种情况：
>
>```c
>#include <stdio.h>                  #include "stdio.h"
>```
>
>其中，使用尖括号（<>），预处理程序 cpp 在系统默认包含文件目录（如/usr/include）中搜索相应的文件；使用双引号，预处理程序 cpp 首先在当前目录中搜寻头文件，如果没有找到，就到指定的 dirname 目录中去寻找。
>在程序设计中，如果需要的这种包含文件分别分布在不同的目录中，就需要逐个使用 -I 选项给出搜索路径。
>
>-Ldirname：将dirname所指出的目录加入到程序函数库文件的目录列表中，是在链接过程中使用的参数。在默认状态下，链接程序 ld 在系统默认路径中（如 /usr/lib）寻找所需要的库文件。这个选项告诉链接程序，首先到 -L 指定的目录中去寻找，然后到系统默认路径中寻找；如果函数库存放在多个目录下，就需要依次使用这个选项，给出相应的存放目录。
>
>-lname：链接时装载名为 libname.a 的函数库。该函数库位于系统默认的目录或者由 -L 选项确定的目录下。例如，-lm 表示链接名为 libm.a 的数学函数库。

# 二、警告提示功能选项

gcc包含完整的出错检查和警告提示功能，它们可以帮助Linux程序员写出更加专业的代码。

(1) -pedantic 选项

当gcc在编译不符合ANSI/ISO C语言标准的源代码时，将产生相应的警告信息。

(2) -Wall 选项

除了 -pedantic 之外，gcc还有一些其他编译选项，也能够产生有用的警告信息。这些选项大多以 -W 开头。其中最有价值的当数 -Wall 了，使用它能够使gcc产生尽可能多的警告信息。

gcc给出的警告信息虽然从严格意义上说不能算作错误，但却可能成为错误的来源。一个优秀的程序员应该尽量避免产生警告信息，使自己的代码始终保持简洁、优美和健壮的特性。

(3) -Werror 选项

在处理警告方面，另一个常用的编译选项是 -Werror 。它要求gcc将所有的警告当成错误进行处理，这在使用自动编译工具(如Make等)时非常有用。如果编译时带上 -Werror 选项，那么gcc会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改。只有当相应的警告信息消除时，才可能将编译过程继续朝前推进。

# 三、库操作选项

在Linux下开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助一个或多个函数库的支持才能够完成相应的功能。
从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（.so 或 .a）的集合。虽然Linux下的大多数函数都默认将头文件放到 /usr/include/ 目录下，而库文件则放到 /usr/lib/ 目录下，但并不是所有的情况都是这样。正因如此，gcc 在编译时必须有自己的办法来查找所需要的头文件和库文件。常用的方法有：
		(1) -I
		可以向 gcc 的头文件搜索路径中添加新的目录。
		(2) -L
		如果使用了不在标准位置的库文件，那么可以通过 -L 选项向 gcc 的库文件搜索路径中添加新的目录。
		(3) -l
		Linux下的库文件在命名时有一个约定，就是应该以 lib 这3个字母开头，由于所有的库文件都遵循了同样的规范，因此在用 -l 选项指定链接的库文件名时可以省去 lib 这3个字母。例如，gcc 在对 -lfoo 进行处理时，会自动去链接名为 libfoo.so 的文件。
		(4) -static
		Linux下的库文件分为两大类，分别是：动态链接库（通常以 .so 结尾）和静态链接库（通常以 .a 结尾）。两者的差别仅在程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。默认情况下，gcc 在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库。如果需要的话，可以在编译时加上 -static 选项，强制使用静态链接库。
		(5) -shared
		生成一个共享的目标文件，它能够与其他的目标一起链接生成一个可执行的文件。

# 四、 调试选项

对于Linux程序员来讲，gdb（GNU Debugger）通过与 gcc 的配合使用，为基于Linux的软件开发提供了一个完善的调试环境。常用的有：
		(1) -g 和 -ggdb
		默认情况下，gcc 在编译时不会将调试符号插入到生成的二进制代码中，因为这样会增加可执行文件的大小。如果需要在编译时生成调试符号信息，可以使用 gcc 的 -g 或 -ggdb 选项。gcc 在产生调试符号时，同样采用了分级的思路，开发人员可以通过在 -g 选项后附加数字1、2、3指定在代码中加入调试信息的多少。默认的级别是2（-g2），此时产生的调试信息包括：扩展的符号表、行号、局部或外部变量信息。级别3（-g3）包含级别2中的所有调试信息以及源代码中定义的宏。级别1（-g1）不包含局部变量和与行号有关的调试信息，因此只能够用于回溯跟踪和堆栈转储。
		回溯追踪：指的是监视程序在运行过程中函数调用历史。
		堆栈转储：则是一种以原始的十六进制格式保存程序执行环境的方法。

>注意：使用任何一个调试选项都会使最终生成的二进制文件的大小急剧增加，同时增加程序在执行时的开销，因此，调试选项通常仅在软件的开发和调试阶段使用。

(2) -p 和 -pg
		会将剖析（Profiling）信息加入到最终生成的二进制代码中。剖析信息对于找出程序的性能瓶颈很有帮助，是协助Linux程序员开发出高性能程序的有力工具。

(3) -save-temps
		保存编译过程中生成的一些列中间文件。

```makefile
gcc test.c -o test -save-temps
```

除了生成执行文件test之外，还保存了test.i 和 test.s 中间文件，供用户查询调试。

------

原文链接：https://blog.csdn.net/baobingji/article/details/84963408