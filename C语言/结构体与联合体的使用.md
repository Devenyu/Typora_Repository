# 结构体与联合体的使用

## 结构体的定义

在C语言中，可以使用结构体（Struct）来存放一组不同类型的数据。结构体的定义形式为：

```c
struct 结构体名{
    结构体所包含的变量或数组
};
```

结构体是一种集合，它里面包含了多个变量或数组，它们的类型可以相同，也可以不同，每个这样的变量或数组都称为结构体的成员（Member）。

```c
struct stu{
    char *name;  //姓名
    int num;  //学号
    int age;  //年龄
    char group;  //所在学习小组
    float score;  //成绩
};
```

stu 为结构体名，它包含了 5 个成员，分别是 name、num、age、group、score。结构体成员的定义方式与变量和数组的定义方式相同，只是不能初始化。

## 结构体变量

既然结构体是一种数据类型，那么就可以用它来定义变量。例如：

```c
struct stu stu1, stu2;
```

定义了两个变量 stu1 和 stu2，它们都是 stu 类型，都由 5 个成员组成。注意关键字struct不能少。

还可以在定义结构体的同时定义结构体变量：

```c
struct stu{
    char *name;  //姓名
    int num;  //学号
    int age;  //年龄
    char group;  //所在学习小组
    float score;  //成绩
} stu1, stu2;
```

如果只需要 stu1、stu2 两个变量，后面不需要再使用结构体名定义其他变量，那么在定义时也可以不给出结构体名，如下所示：

```c
struct{  //没有写 stu
    char *name;  //姓名
    int num;  //学号
    int age;  //年龄
    char group;  //所在学习小组
    float score;  //成绩
} stu1, stu2;
```

这样的写法很简单，但是因为没有结构体名，后面就没法用该结构体定义新的变量了。

## 结构体大小计算

运算符sizeof可以计算出给定类型的大小，对于32位系统来说，sizeof(char) = 1; sizeof(int) = 4。

结构体中的成员可以是不同的数据类型，成员按照定义时的顺序依次存储在连续的内存空间。和数组不一样的是，结构体的大小不是所有成员大小简单的相加，需要考虑到系统在存储结构体变量时的地址对齐问题。看下面这样的一个结构体：

```c
　　struct stu1
　　{
      int i;
      char c;
      int j;
　　}；
```

先介绍一个相关的概念——偏移量。偏移量指的是结构体变量中成员的地址和结构体变量地址 的差。结构体大小等于最后一个成员的偏移量加上最后一个成员的大小。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏 移量为0。第二个成员c的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成 员的大小（4+1）,其值为5。

>实际上，由于存储变量时地址对齐的要求，编译器在编译程序时会遵循两条原则：
>		一、结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍）
>		二、结构体大小必须是所有成员大小的整数倍。

由此可见，大家在定义结构体类型时需要考虑 到字节对齐的情况，不同的顺序会影响到结构体的大小。对比下面两种定义顺序

```c
　　struct stu3
　　{
      char c1;
      int i;
      char c2;
　　}

　　struct stu4
　　{
      char c1;
      char c2;
      int i;
　　}
```

虽然结构体stu3和stu4中成员都一样，但sizeof(struct stu3)的值为12而sizeof(struct stu4)的值为8。

如果结构体中的成员又是另外一种结构体类型时应该怎么计算呢？只需把其展开即可。但有一点需要注意，展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。看下面的例子：

```c
　　struct stu5
　　{
      short i;

      struct{
        char c;
        int j;
      } ss;

      int k;
　　}
```

结构体stu5的成员ss.c的偏移量应该是4，而不是2。整个结构体大小应该是16。

## 结构体与指针

指针也可以指向一个结构体，定义的形式一般为：

```c
struct 结构体名 *变量名;
```

具体的例子如下所示：

```c
struct Man{
    char name[20];
    int age;
};
void main(){
    struct Man m1 = {"Jack",30};
    //结构体指针
    struct Man *p = &m1;
    printf("%s,%d\n", m1.name, m1.age);
    printf("%s,%d\n",(*p).name,(*p).age);
    //“->”（箭头）是“(*p).”简写形式
    printf("%s,%d\n", p->name, p->age);
    //(*env)->

    system("pause");
}

```

## 联合体（共用体）

结构体（Struct）是一种构造类型或复杂类型，它可以包含多个类型不同的成员。在C语言中，还有另外一种和结构体非常类似的语法，叫做共用体（Union），它的定义格式为：

```c
union 共用体名{
    成员列表
};
```

共用体有时也被成为联合体；

结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。

结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。

共用体也是一种自定义类型，可以通过它来创建变量，例如：

```c
union data{
    int n;
    char ch;
    double f;
};
union data a, b, c;
```

上面是先定义共用体，再创建变量，也可以在定义共用体的同时创建变量：

```c
union data{
    int n;
    char ch;
    double f;
} a, b, c;
```

共用体 data 中，成员 f 占用的内存最多，为 8 个字节，所以 data 类型的变量（也就是 a、b、c）也占用 8 个字节的内存。

## 实际应用

在实际应用中我们可以利用联合体来实现数据类型的转换，例如将一个INT类型的数据转换为四个CHAR类型的数据，也可以利用联合体加结构体的形式来实现变量名称或类型的转换，如下所示：

```c
typedef union
{
    short datasize;
    int result;
}ADD_RES;
typedef struct 
{
    uint16_t header;
    uint16_t cmd;
    ADD_RES address_result;
}RXBUFF_HEADER;
```

在用户需要数据大小时，可以输出short类型的数据，在用户需要数据结果时，可以输出int类型的数据。
